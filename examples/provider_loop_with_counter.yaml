# Run this file with the test-server, then specify the PORT as a parameter to this try or run script.

vars:
  port: "${e:PORT}"
  counter_limit: 5

load_pattern:
  - !linear
      from: 100%
      to: 100%
      over: 15s

providers:
  a: !range
  b: !response
  c: !response

loggers:
  test:
    to: !stderr

endpoints:
  - method: POST
    url: http://localhost:${v:port}
    body: !str '{"a": ${p:a}}'
    # peak_load: 1hps
    provides:
      b:
        query:
          select:
            value: response.body.a
            counter: 0
        send: block
    logs:
      test:
        select:
          ts: epoch("ms")
          a: response.body.a
    on_demand: true

  - method: POST
    url: http://localhost:${v:port}
    body: !str '{"b": ${x:${p:b}.value}, "counter": ${x:${p:b}.counter}}'
    peak_load: 5hps
    # on_demand: true # We can't do on_demand due to a bug where it can't figure out that we provider for ourselves
    provides:
      b:
        query:
          select:
            value: response.body.b # Put it back on 'b' to reuse
            counter: b.counter + 1
          where: b.counter < _v.counter_limit
        send: if_not_full
      c:
        query:
          select: response.body.b # Put it on  once we've hit counter_limit
          where: b.counter >= _v.counter_limit
        send: if_not_full
    logs:
      test:
        select:
          ts: epoch("ms")
          b: response.body.b
          counter: b.counter

  - method: POST
    url: http://localhost:${v:port}
    body: !str '{"c": ${p:c}}'
    peak_load: 1hps
    logs:
      test:
        select:
          ts: epoch("ms")
          c: response.body.c
